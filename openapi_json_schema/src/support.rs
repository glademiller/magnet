//! "Runtime" support for `magnet_derive` -- quasi-private functions.
use serde_json;

/// Describes a lower or upper bound.
#[doc(hidden)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Bound {
    /// The range is not bounded.
    Unbounded,
    /// The range is bounded, the bound is in the range.
    Inclusive(f64),
    /// The range is bounded, the bound is not in the range.
    Exclusive(f64),
}

/// Describes both the lower and the upper bounds of a range.
#[doc(hidden)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Bounds {
    /// The lower bound of the range.
    pub lower: Bound,
    /// The upper bound of the range.
    pub upper: Bound,
}

/// Based on bounds parsed from attributes, generates minimum and maximum
/// constraints and adds them to a JSON schema. Calls to this functions
/// are to be made from `magnet_derive`'d, generated code only.
#[doc(hidden)]
pub fn extend_schema_with_bounds(
    mut schema: openapiv3::Schema,
    bounds: Bounds,
) -> openapiv3::Schema {
    // {
    //     let obj = schema.as_object_mut().expect("Schema is not an object");
    //     match bounds.lower {
    //         Bound::Unbounded => {}
    //         Bound::Inclusive(minimum) => {
    //             obj.insert(
    //                 "minimum".to_string(),
    //                 serde_json::Value::Number(
    //                     serde_json::Number::from_f64(minimum).expect("Not a number"),
    //                 ),
    //             );
    //             obj.insert(
    //                 "exclusiveMinimum".to_string(),
    //                 serde_json::Value::Bool(false),
    //             );
    //         }
    //         Bound::Exclusive(minimum) => {
    //             obj.insert(
    //                 "minimum".to_string(),
    //                 serde_json::Value::Number(
    //                     serde_json::Number::from_f64(minimum).expect("Not a number"),
    //                 ),
    //             );
    //             obj.insert(
    //                 "exclusiveMinimum".to_string(),
    //                 serde_json::Value::Bool(true),
    //             );
    //         }
    //     }

    //     match bounds.upper {
    //         Bound::Unbounded => {}
    //         Bound::Inclusive(maximum) => {
    //             obj.insert(
    //                 "maximum".to_string(),
    //                 serde_json::Value::Number(
    //                     serde_json::Number::from_f64(maximum).expect("Not a number"),
    //                 ),
    //             );
    //             obj.insert(
    //                 "exclusiveMaximum".to_string(),
    //                 serde_json::Value::Bool(false),
    //             );
    //         }
    //         Bound::Exclusive(maximum) => {
    //             obj.insert(
    //                 "maximum".to_string(),
    //                 serde_json::Value::Number(
    //                     serde_json::Number::from_f64(maximum).expect("Not a number"),
    //                 ),
    //             );
    //             obj.insert(
    //                 "exclusiveMaximum".to_string(),
    //                 serde_json::Value::Bool(true),
    //             );
    //         }
    //     }
    // }

    schema
}

/// This function should not be used directly; calls to it are only generated by
/// `magnet_derive` when emitting code for internally-tagged newtype variants.
///
/// If the newtype schema comes from a struct, just extend its "required"
/// and "properties" fields to include the tag and the variant name.
///
/// If the newtype schema comes from a map-like construct with dynamic keys,
/// just create the "required" and "properties" fields, with their single
/// element being the tag and the variant name.
///
/// If the newtype schema comes from an enum with supported structure,
/// e.g. all variants are structs or newtypes over structs, then recursively
/// flatten and check the `anyOf` / `oneOf` structure of the schema, and
/// add the tag and the variant name to each.
/// TODO(H2CO3): implement me --- this scenario is yet to be handled.
///
/// Every other case is considered an error.
#[doc(hidden)]
pub fn extend_schema_with_tag(
    schema: openapiv3::Schema,
    tag: &str,
    variant: &str,
) -> openapiv3::Schema {
    if schema_is_struct(&schema) || schema_is_map(&schema) {
        if let openapiv3::Schema::Schema(item) = schema {
            openapiv3::Schema::Schema(Box::new(extend_object_schema_with_tag(
                (*item).clone(),
                tag,
                variant,
            )))
        } else {
            panic!("This should be impossible we just checked with schema_is_struct")
        }
    } else if schema_is_enum(&schema) {
        extend_enum_schema_with_tag(schema, tag, variant)
    } else {
        panic!("newtype variant doesn't describe a struct, a map, or an enum?!")
    }
}

/// Check if a schema describes a struct: an object with a fixed set of keys.
/// Note: we could check for `"type"` being an array containing `"object"`
/// as well, in case it's an `Option`, but internally-tagged newtype variants
/// around `Option` aren't supported by Serde anyway.
fn schema_is_struct(doc: &openapiv3::Schema) -> bool {
    if let openapiv3::Schema::Schema(item) = doc {
        if let openapiv3::SchemaVariant::Object { .. } = **item {
            return true;
        }
    }
    false
}

/// Check if a schema holds a dynamic set of keys.
/// Note: we could check for `"type"` being an array containing `"object"`
/// as well, in case it's an `Option`, but internally-tagged newtype variants
/// around `Option` aren't supported by Serde anyway.
fn schema_is_map(doc: &openapiv3::Schema) -> bool {
    if let openapiv3::Schema::Schema(item) = doc {
        if let openapiv3::SchemaVariant::Object {
            additional_properties,
            ..
        } = **item
        {
            return additional_properties;
        }
    }
    false
}

/// Check if a BSON schema describes an enum.
fn schema_is_enum(doc: &openapiv3::Schema) -> bool {
    if let openapiv3::Schema::AnyOf { .. } = doc {
        true
    } else {
        false
    }
}

/// Extends a `struct`'s schema so that it describes an internally-tagged variant.
fn extend_object_schema_with_tag(
    mut schema: openapiv3::SchemaVariant,
    tag: &str,
    variant: &str,
) -> openapiv3::SchemaVariant {
    match schema {
        openapiv3::SchemaVariant::Object {
            ref mut required,
            ref mut properties,
            ..
        } => {
            required.push(tag.into());
            properties.insert(
                tag.into(),
                openapiv3::ReferenceOr::Item(Box::new(openapiv3::Schema::Schema(Box::new(
                    openapiv3::SchemaVariant::String {
                        schema_data: openapiv3::SchemaData {
                            nullable: false,
                            read_only: false,
                            write_only: false,
                            deprecated: false,
                            external_docs: None,
                            example: None,
                            title: None,
                            description: None,
                        },
                        pattern: None,
                        format: openapiv3::VariantOrUnknownOrEmpty::Empty,
                        enumeration: vec![variant.into()],
                    },
                )))),
            );
        }
        _ => (),
    };

    schema
}

/// Extends an `enum`'s schema so that it describes an internally-tagged variant.
fn extend_enum_schema_with_tag(
    mut schema: openapiv3::Schema,
    tag: &str,
    variant: &str,
) -> openapiv3::Schema {
    match schema {
        openapiv3::Schema::AnyOf { ref mut any_of } => {
            for schema in any_of {
                match schema {
                    openapiv3::ReferenceOr::Item(ref mut schema) => {
                        *schema = extend_schema_with_tag(schema.clone(), tag, variant);
                    }
                    _ => (),
                }
            }
        }
        openapiv3::Schema::OneOf { ref mut one_of } => {
            for schema in one_of {
                match schema {
                    openapiv3::ReferenceOr::Item(ref mut schema) => {
                        *schema = extend_schema_with_tag(schema.clone(), tag, variant);
                    }
                    _ => (),
                }
            }
        }
        _ => (),
    }
    schema
}
