//! "Runtime" support for `magnet_derive` -- quasi-private functions.
use serde_json;

/// Describes a lower or upper bound.
#[doc(hidden)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Bound {
    /// The range is not bounded.
    Unbounded,
    /// The range is bounded, the bound is in the range.
    Inclusive(f64),
    /// The range is bounded, the bound is not in the range.
    Exclusive(f64),
}

/// Describes both the lower and the upper bounds of a range.
#[doc(hidden)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Bounds {
    /// The lower bound of the range.
    pub lower: Bound,
    /// The upper bound of the range.
    pub upper: Bound,
}

/// Based on bounds parsed from attributes, generates minimum and maximum
/// constraints and adds them to a JSON schema. Calls to this functions
/// are to be made from `magnet_derive`'d, generated code only.
#[doc(hidden)]
pub fn extend_schema_with_bounds(
    mut schema: serde_json::Value,
    bounds: Bounds,
) -> serde_json::Value {
    {
        let obj = schema.as_object_mut().expect("Schema is not an object");
        match bounds.lower {
            Bound::Unbounded => {}
            Bound::Inclusive(minimum) => {
                obj.insert(
                    "minimum".to_string(),
                    serde_json::Value::Number(
                        serde_json::Number::from_f64(minimum).expect("Not a number"),
                    ),
                );
                obj.insert(
                    "exclusiveMinimum".to_string(),
                    serde_json::Value::Bool(false),
                );
            }
            Bound::Exclusive(minimum) => {
                obj.insert(
                    "minimum".to_string(),
                    serde_json::Value::Number(
                        serde_json::Number::from_f64(minimum).expect("Not a number"),
                    ),
                );
                obj.insert(
                    "exclusiveMinimum".to_string(),
                    serde_json::Value::Bool(true),
                );
            }
        }

        match bounds.upper {
            Bound::Unbounded => {}
            Bound::Inclusive(maximum) => {
                obj.insert(
                    "maximum".to_string(),
                    serde_json::Value::Number(
                        serde_json::Number::from_f64(maximum).expect("Not a number"),
                    ),
                );
                obj.insert(
                    "exclusiveMaximum".to_string(),
                    serde_json::Value::Bool(false),
                );
            }
            Bound::Exclusive(maximum) => {
                obj.insert(
                    "maximum".to_string(),
                    serde_json::Value::Number(
                        serde_json::Number::from_f64(maximum).expect("Not a number"),
                    ),
                );
                obj.insert(
                    "exclusiveMaximum".to_string(),
                    serde_json::Value::Bool(true),
                );
            }
        }
    }

    schema
}

/// This function should not be used directly; calls to it are only generated by
/// `magnet_derive` when emitting code for internally-tagged newtype variants.
///
/// If the newtype schema comes from a struct, just extend its "required"
/// and "properties" fields to include the tag and the variant name.
///
/// If the newtype schema comes from a map-like construct with dynamic keys,
/// just create the "required" and "properties" fields, with their single
/// element being the tag and the variant name.
///
/// If the newtype schema comes from an enum with supported structure,
/// e.g. all variants are structs or newtypes over structs, then recursively
/// flatten and check the `anyOf` / `oneOf` structure of the schema, and
/// add the tag and the variant name to each.
/// TODO(H2CO3): implement me --- this scenario is yet to be handled.
///
/// Every other case is considered an error.
#[doc(hidden)]
pub fn extend_schema_with_tag(
    schema: serde_json::Value,
    tag: &str,
    variant: &str,
) -> serde_json::Value {
    if schema_is_struct(&schema) {
        extend_struct_schema_with_tag(schema, tag, variant)
    } else if schema_is_map(&schema) {
        extend_map_schema_with_tag(schema, tag, variant)
    } else if schema_is_enum(&schema) {
        extend_enum_schema_with_tag(schema, tag, variant)
    } else {
        panic!("newtype variant doesn't describe a struct, a map, or an enum?!")
    }
}

/// Check if a schema describes a struct: an object with a fixed set of keys.
/// Note: we could check for `"type"` being an array containing `"object"`
/// as well, in case it's an `Option`, but internally-tagged newtype variants
/// around `Option` aren't supported by Serde anyway.
fn schema_is_struct(doc: &serde_json::Value) -> bool {
    doc.get("type")
        .map(|v| {
            if let serde_json::Value::String(v) = v {
                v == "object"
            } else {
                false
            }
        })
        .unwrap_or(false)
        && doc.get("properties").is_some()
}

/// Check if a schema holds a dynamic set of keys.
/// Note: we could check for `"type"` being an array containing `"object"`
/// as well, in case it's an `Option`, but internally-tagged newtype variants
/// around `Option` aren't supported by Serde anyway.
fn schema_is_map(doc: &serde_json::Value) -> bool {
    doc.get("type")
        .map(|v| {
            if let serde_json::Value::String(v) = v {
                v == "object"
            } else {
                false
            }
        })
        .unwrap_or(false)
        && doc.get("additionalProperties").is_some()
}

/// Check if a BSON schema describes an enum.
fn schema_is_enum(doc: &serde_json::Value) -> bool {
    doc.get("anyOf").map(|v| v.is_array()).unwrap_or(false)
}

/// Extends a `struct`'s schema so that it describes an internally-tagged variant.
fn extend_struct_schema_with_tag(
    mut schema: serde_json::Value,
    tag: &str,
    variant: &str,
) -> serde_json::Value {
    {
        let obj = schema.as_object_mut().expect("Schema is not an object");
        let mut required = match obj.remove("required") {
            Some(serde_json::Value::Array(arr)) => arr,
            Some(_) => panic!("`required` is not an array in struct obj?!"),
            None => panic!("`required` key not found in struct obj?!"),
        };
        let mut properties = match obj.remove("properties") {
            Some(serde_json::Value::Object(doc)) => doc,
            Some(_) => panic!("`properties` is not a serde_json::Value in struct obj?!"),
            None => panic!("`properties` key not found in struct obj?!"),
        };

        // TODO(H2CO3): check for duplicate items and keys --
        // however, Serde should catch them too, shouldn't it?
        required.push(tag.into());
        properties.insert(tag.to_string(), json!({ "enum": [variant] }));

        obj.insert("required".to_string(), serde_json::Value::Array(required));
        obj.insert(
            "properties".to_string(),
            serde_json::Value::Object(properties),
        );
    }
    schema
}

/// Extends a map's schema so that it describes an internally-tagged variant.
fn extend_map_schema_with_tag(
    mut schema: serde_json::Value,
    tag: &str,
    variant: &str,
) -> serde_json::Value {
    {
        let obj = schema.as_object_mut().expect("Schema is not an object");
        // TODO(H2CO3): check for existence of the two following fields?
        obj.insert(
            "required".to_string(),
            serde_json::Value::Array(vec![tag.into()]),
        );
        obj.insert(
            "properties".to_string(),
            json!({ tag: { "enum": [ variant ] } }),
        );
    }
    schema
}

/// Extends an `enum`'s schema so that it describes an internally-tagged variant.
fn extend_enum_schema_with_tag(
    _schema: serde_json::Value,
    _tag: &str,
    _variant: &str,
) -> serde_json::Value {
    // TODO(H2CO3): recursively and transitively walk `anyOf` / `oneOf`
    // structure, until the leaves (struct or newtype-around-struct) are reached
    // or an error occurs (a non struct or newtype-around-struct type is found).
    unimplemented!("internally-tagged newtype variants around enums are not yet supported")
}
